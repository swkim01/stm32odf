#
# @file from https://github.com/Neutree/c_cpp_project_framework
# @author neucrack
#

import argparse
import os, sys
import json

kconfig_lib_path = sys.path[0]+"/Kconfiglib"
sys.path.append(kconfig_lib_path)

import kconfiglib
from menuconfig import menuconfig
from guiconfig import menuconfig as guiconfig


def _cmake_contents(kconfig, header):
    chunks = [header]
    add = chunks.append
    config_vars = []
    for sym in kconfig.unique_defined_syms:
        # _write_to_conf is determined when the value is calculated. This
        # is a hidden function call due to property magic.
        val = sym.str_value
        if not sym._write_to_conf:
            continue
        if sym.orig_type in (kconfiglib.BOOL, kconfiglib.TRISTATE) and val == "n":
            val = ""
        add("set({}{} \"{}\")\n".format(
            kconfig.config_prefix, sym.name, val))
        config_vars.append(str(kconfig.config_prefix+sym.name))
    add("set(CONFIGS_LIST {})\n".format(";".join(config_vars)))
    return "".join(chunks)


def write_config(kconfig, filename, gui):
    print("-- Write makefile config at: " + filename)
    if not gui:
        kconfig.write_config(filename)

def write_cmake(kconfig, filename, gui):
    print("-- Write  cmake  config  at: " + filename)
    cmake_conf_header = "# Generated by c_cpp_project_framework(https://github.com/Neutree/c_cpp_project_framework)\n"
    cmake_conf_header += "### DO NOT edit this file!! ###\n\n"
    cmake_conf_content = _cmake_contents(kconfig, cmake_conf_header)
    # don't change file info if config no change
    if os.path.exists(filename):
        with open(filename) as f:
            if f.read() == cmake_conf_content:
                return
    f = open(filename, "w")
    f.write(cmake_conf_content)
    f.close()


def write_header(kconfig, filename, gui):
    print("-- write  c header file  at: " + filename)
    kconfig.write_autoconf(filename)

def get_json_values(kconfig):
    config_dict = {}
    for sym in kconfig.unique_defined_syms:
        # _write_to_conf is determined when the value is calculated. This
        # is a hidden function call due to property magic.
        val = sym.str_value
        if not sym._write_to_conf:
            continue
        if sym.orig_type in (kconfiglib.BOOL, kconfiglib.TRISTATE):
            val = (val != "n")
        elif sym.orig_type == kconfiglib.HEX:
            val = int(val, 16)
        elif sym.orig_type == kconfiglib.INT:
            val = int(val)
        config_dict[sym.name] = val
    return config_dict


def write_json(kconfig, filename, gui):
    config_dict = get_json_values(kconfig)
    with open(filename, "w") as f:
        json.dump(config_dict, f, indent=4, sort_keys=True)

def walk_menu(kconfig, callback):
    node = kconfig.top_node.list
    if not node:
        return
    seen_items = set()
    while True:
        if not node.item in seen_items:
            callback(node)
            seen_items.add(node.item)
        if node.list:
            node = node.list
        elif node.next:
            node = node.next
        else:
            while node.parent:
                node = node.parent
                if node.next:
                    node = node.next
                    break
            else:
                return

def write_json_menus(kconfig, filename, gui):
    result = [] # root level items
    node_lookup = {} # lookup from MenuNode to an item in result

    def write_node(node):
        try:
            json_parent = node_lookup[node.parent]["children"]
        except KeyError:
            assert not node.parent in node_lookup # if fails,  we have a parent node with no "children" entity (ie a bug)
            json_parent = result  # root level node

        # node.kconfig.y means node has no dependency,
        if node.dep is node.kconfig.y:
            depends = None
        else:
            depends = kconfiglib.expr_str(node.dep)

        try:
            is_menuconfig = node.is_menuconfig
        except AttributeError:
            is_menuconfig = False
        new_json = None
        if node.item == kconfiglib.MENU or is_menuconfig:
            new_json = { "type" : "menu",
                         "title" : node.prompt[0],
                         "depends_on": depends,
                         "children": []
            }
            if is_menuconfig:
                sym = node.item
                #print(dir(node)) #print(node)
                #print(node.prompt)
                #print(node.item)
                #new_json["name"] = sym.name #new_json["name"] = node.prompt[0]
                #new_json["help"] = node.help
                new_json["is_menuconfig"] = is_menuconfig
                #greatest_range = None
                #if len(sym.ranges) > 0:
                #    # Note: Evaluating the condition using kconfiglib's expr_value
                #    # should have one condition which is true
                #    for min_range, max_range, cond_expr in sym.ranges:
                #        if kconfiglib.expr_value(cond_expr):
                #            greatest_range = [min_range, max_range]
                #new_json["range"] = greatest_range
        elif isinstance(node.item, kconfiglib.Symbol):
            sym = node.item
            greatest_range = None
            if len(sym.ranges) > 0:
                # Note: Evaluating the condition using kconfiglib's expr_value
                # should have one condition which is true
                for min_range, max_range, cond_expr in sym.ranges:
                    if kconfiglib.expr_value(cond_expr):
                        greatest_range = [int(min_range.str_value), int(max_range.str_value)]

            new_json = {
                "type" : kconfiglib.TYPE_TO_STR[sym.type],
                "name" : sym.name,
                "title": node.prompt[0] if node.prompt else None,
                "depends_on" : depends,
                "help": node.help,
                "range" : greatest_range,
                "children": [],
            }
        elif isinstance(node.item, kconfiglib.Choice):
            choice = node.item
            new_json = {
                "type": "choice",
                "title": node.prompt[0],
                "name": choice.name,
                "depends_on" : depends,
                "help": node.help,
                "children": []
            }

        if new_json:
            json_parent.append(new_json)
            node_lookup[node] = new_json

    walk_menu(kconfig, write_node)
    with open(filename, "w") as f:
        f.write(json.dumps(result, sort_keys=True, indent=4))

OUTPUT_FORMATS = {"makefile": write_config,
                  "header": write_header,
                  "cmake": write_cmake,
                  "json": write_json,
                  "json_menus": write_json_menus,
                  }

def main():
    parser = argparse.ArgumentParser(description='menuconfig tool', prog=os.path.basename(sys.argv[0]))

    parser.add_argument('--kconfig',
                    help='KConfig file',
                    default='Kconfig',
                    metavar='FILENAME',
                    required=None)

    parser.add_argument('--defaults',
                    action='append',
                    default=[],
                    help='Optional project defaults file. '
                            'Multiple files can be specified using multiple --defaults arguments.',
                    metavar="FILENAME"
                    )

    parser.add_argument('--output', nargs=2, action='append',
                        help='Write output file (format and output filename)',
                        metavar=('FORMAT', 'FILENAME'),
                        default=[])

    parser.add_argument('--env',
                    action='append',
                    default=[],
                    help='Environment to set when evaluating the config file', 
                    metavar='VAR=VALUE'
                    )

    parser.add_argument("--menuconfig",
                    help="Open menuconfig GUI interface",
                    choices=["False", "True"],
                    default="False",
                    )

    parser.add_argument("--guiconfig",
                    help="Open guiconfig GUI interface",
                    choices=["False", "True"],
                    default="False",
                    )

    args = parser.parse_args()

    for env in args.env:
        env = env.split("=")
        var = env[0]
        value = env[1]
        os.environ[var] = value

    out_format = {"makefile": ".config"}
    for fmt, filename in args.output:
        if fmt not in OUTPUT_FORMATS.keys():
            print("Format %s not supported! Known formats:%s" %(fmt, OUTPUT_FORMATS.keys()))
            sys.exit(1)
        out_format[fmt] = filename
    
    if out_format["makefile"] != ".config":
        os.environ["KCONFIG_CONFIG"] = out_format["makefile"]

    kconfig = kconfiglib.Kconfig(args.kconfig)

    # load config, so if config file exist, the default file may 
    #              not take effect, if want to use default, 
    #              remove the config file in build directory
    if not os.path.exists(out_format["makefile"]):
        for path in args.defaults:
            if not os.path.exists(path):
                raise ValueError("Path %s not found!" %(path))
            print("-- Load default:", path)
            kconfig.load_config(path, replace=False)
    else:
        kconfig.load_config()

    if args.menuconfig == "True":
        menuconfig(kconfig)
    elif args.guiconfig == "True":
        guiconfig(kconfig)

    # write back
    for fmt, filename in out_format.items():
        dir = os.path.split(filename)[0]
        if not os.path.exists(dir):
            os.makedirs(dir)

    for fmt, filename in out_format.items():
        func = OUTPUT_FORMATS[fmt]
        func(kconfig, filename, args.menuconfig == "True" or args.guiconfig == "True")

__version__ = "0.1"

class FatalError(RuntimeError):
    """
    Class for runtime errors
    """
    pass

if __name__ == '__main__':
    try:
        main()
    except FatalError as e:
        print("A fatal error occurred: %s", e)
        sys.exit(2)
